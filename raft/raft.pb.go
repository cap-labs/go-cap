// Code generated by protoc-gen-go. DO NOT EDIT.
// source: raft.proto

package raft

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	Status_leader    Status = 0
	Status_follower  Status = 1
	Status_candidate Status = 2
)

var Status_name = map[int32]string{
	0: "leader",
	1: "follower",
	2: "candidate",
}

var Status_value = map[string]int32{
	"leader":    0,
	"follower":  1,
	"candidate": 2,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}

type Entry_Type int32

const (
	Entry_normal        Entry_Type = 0
	Entry_changeCluster Entry_Type = 1
)

var Entry_Type_name = map[int32]string{
	0: "normal",
	1: "changeCluster",
}

var Entry_Type_value = map[string]int32{
	"normal":        0,
	"changeCluster": 1,
}

func (x Entry_Type) String() string {
	return proto.EnumName(Entry_Type_name, int32(x))
}

func (Entry_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{5, 0}
}

type Peer struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Addresses            []string `protobuf:"bytes,2,rep,name=addresses,proto3" json:"addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}

func (m *Peer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Peer.Unmarshal(m, b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return xxx_messageInfo_Peer.Size(m)
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Peer) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// Cluster the peers collection
type Cluster struct {
	// Peers
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
	// the cluster leader heartbeat timeout ticks
	HeartbeatTimeout uint64 `protobuf:"varint,2,opt,name=heartbeatTimeout,proto3" json:"heartbeatTimeout,omitempty"`
	// If a follower receives no communication over a period of time called the
	// election timeout, then it assumes there is no vi- able leader and begins an
	// election to choose a new leader
	ElectionTimeout      uint64   `protobuf:"varint,3,opt,name=electionTimeout,proto3" json:"electionTimeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{1}
}

func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Cluster.Unmarshal(m, b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return xxx_messageInfo_Cluster.Size(m)
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Cluster) GetHeartbeatTimeout() uint64 {
	if m != nil {
		return m.HeartbeatTimeout
	}
	return 0
}

func (m *Cluster) GetElectionTimeout() uint64 {
	if m != nil {
		return m.ElectionTimeout
	}
	return 0
}

// Receiver implementation:
// 1. Reply false if term < currentTerm (§5.1)
// 2. If votedFor is null or candidateId, and candidate’s log is at
//    least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)
type RequestVote struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	CandidateId          string   `protobuf:"bytes,2,opt,name=candidateId,proto3" json:"candidateId,omitempty"`
	LastLogIndex         uint64   `protobuf:"varint,3,opt,name=lastLogIndex,proto3" json:"lastLogIndex,omitempty"`
	LastLogTerm          uint64   `protobuf:"varint,4,opt,name=lastLogTerm,proto3" json:"lastLogTerm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestVote) Reset()         { *m = RequestVote{} }
func (m *RequestVote) String() string { return proto.CompactTextString(m) }
func (*RequestVote) ProtoMessage()    {}
func (*RequestVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{2}
}

func (m *RequestVote) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestVote.Unmarshal(m, b)
}
func (m *RequestVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestVote.Marshal(b, m, deterministic)
}
func (m *RequestVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVote.Merge(m, src)
}
func (m *RequestVote) XXX_Size() int {
	return xxx_messageInfo_RequestVote.Size(m)
}
func (m *RequestVote) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVote.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVote proto.InternalMessageInfo

func (m *RequestVote) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestVote) GetCandidateId() string {
	if m != nil {
		return m.CandidateId
	}
	return ""
}

func (m *RequestVote) GetLastLogIndex() uint64 {
	if m != nil {
		return m.LastLogIndex
	}
	return 0
}

func (m *RequestVote) GetLastLogTerm() uint64 {
	if m != nil {
		return m.LastLogTerm
	}
	return 0
}

type ResponseVote struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	VoteGranted          bool     `protobuf:"varint,2,opt,name=voteGranted,proto3" json:"voteGranted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseVote) Reset()         { *m = ResponseVote{} }
func (m *ResponseVote) String() string { return proto.CompactTextString(m) }
func (*ResponseVote) ProtoMessage()    {}
func (*ResponseVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{3}
}

func (m *ResponseVote) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseVote.Unmarshal(m, b)
}
func (m *ResponseVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseVote.Marshal(b, m, deterministic)
}
func (m *ResponseVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseVote.Merge(m, src)
}
func (m *ResponseVote) XXX_Size() int {
	return xxx_messageInfo_ResponseVote.Size(m)
}
func (m *ResponseVote) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseVote.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseVote proto.InternalMessageInfo

func (m *ResponseVote) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ResponseVote) GetVoteGranted() bool {
	if m != nil {
		return m.VoteGranted
	}
	return false
}

// Receiver implementation:
// 1. Reply false if term < currentTerm (§5.1)
// 2. Reply false if log doesn’t contain an entry at prevLogIndex
//    whose term matches prevLogTerm (§5.3)
// 3. If an existing entry conflicts with a new one (same index
//    but different terms), delete the existing entry and all that
//    follow it (§5.3)
// 4. Append any new entries not already in the log
// 5. If leaderCommit > commitIndex, set commitIndex =
//    min(leaderCommit, index of last new entry)
type RequestAppendEntries struct {
	Term         uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	LeaderId     string   `protobuf:"bytes,2,opt,name=leaderId,proto3" json:"leaderId,omitempty"`
	PrevLogIndex uint64   `protobuf:"varint,3,opt,name=prevLogIndex,proto3" json:"prevLogIndex,omitempty"`
	PrevLogTerm  uint64   `protobuf:"varint,4,opt,name=prevLogTerm,proto3" json:"prevLogTerm,omitempty"`
	Entries      [][]byte `protobuf:"bytes,5,rep,name=entries,proto3" json:"entries,omitempty"`
	// send more than one for efficiency)
	LeaderCommit         uint64   `protobuf:"varint,6,opt,name=leaderCommit,proto3" json:"leaderCommit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestAppendEntries) Reset()         { *m = RequestAppendEntries{} }
func (m *RequestAppendEntries) String() string { return proto.CompactTextString(m) }
func (*RequestAppendEntries) ProtoMessage()    {}
func (*RequestAppendEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{4}
}

func (m *RequestAppendEntries) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestAppendEntries.Unmarshal(m, b)
}
func (m *RequestAppendEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestAppendEntries.Marshal(b, m, deterministic)
}
func (m *RequestAppendEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestAppendEntries.Merge(m, src)
}
func (m *RequestAppendEntries) XXX_Size() int {
	return xxx_messageInfo_RequestAppendEntries.Size(m)
}
func (m *RequestAppendEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestAppendEntries.DiscardUnknown(m)
}

var xxx_messageInfo_RequestAppendEntries proto.InternalMessageInfo

func (m *RequestAppendEntries) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestAppendEntries) GetLeaderId() string {
	if m != nil {
		return m.LeaderId
	}
	return ""
}

func (m *RequestAppendEntries) GetPrevLogIndex() uint64 {
	if m != nil {
		return m.PrevLogIndex
	}
	return 0
}

func (m *RequestAppendEntries) GetPrevLogTerm() uint64 {
	if m != nil {
		return m.PrevLogTerm
	}
	return 0
}

func (m *RequestAppendEntries) GetEntries() [][]byte {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *RequestAppendEntries) GetLeaderCommit() uint64 {
	if m != nil {
		return m.LeaderCommit
	}
	return 0
}

type Entry struct {
	Index                uint64     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Term                 uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Type                 Entry_Type `protobuf:"varint,3,opt,name=type,proto3,enum=raft.Entry_Type" json:"type,omitempty"`
	Data                 []byte     `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{5}
}

func (m *Entry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Entry.Unmarshal(m, b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return xxx_messageInfo_Entry.Size(m)
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Entry) GetType() Entry_Type {
	if m != nil {
		return m.Type
	}
	return Entry_normal
}

func (m *Entry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ResponseAppendEntries struct {
	Term                 uint64   `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Success              bool     `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseAppendEntries) Reset()         { *m = ResponseAppendEntries{} }
func (m *ResponseAppendEntries) String() string { return proto.CompactTextString(m) }
func (*ResponseAppendEntries) ProtoMessage()    {}
func (*ResponseAppendEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{6}
}

func (m *ResponseAppendEntries) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseAppendEntries.Unmarshal(m, b)
}
func (m *ResponseAppendEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseAppendEntries.Marshal(b, m, deterministic)
}
func (m *ResponseAppendEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseAppendEntries.Merge(m, src)
}
func (m *ResponseAppendEntries) XXX_Size() int {
	return xxx_messageInfo_ResponseAppendEntries.Size(m)
}
func (m *ResponseAppendEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseAppendEntries.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseAppendEntries proto.InternalMessageInfo

func (m *ResponseAppendEntries) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ResponseAppendEntries) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// Invoked by leader to send chunks of a snapshot to a follower. Leaders always
// send chunks in order.
// Receiver implementation:
// 1. Reply immediately if term < currentTerm
// 2. Create new snapshot file if first chunk (offset is 0)
// 3. Write data into snapshot file at given offset
// 4. Reply and wait for more data chunks if done is false
// 5. Save snapshot file, discard any existing or partial snapshot
//    with a smaller index
// 6. If existing log entry has same index and term as snapshot’s
//    last included entry, retain log entries following it and reply
// 7. Discard the entire log
// 8. Reset state machine using snapshot contents (and load
//    snapshot’s cluster configuration)
type RequestInstallSnapshot struct {
	Term              uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	LeaderId          string `protobuf:"bytes,2,opt,name=leaderId,proto3" json:"leaderId,omitempty"`
	LastIncludedIndex uint64 `protobuf:"varint,3,opt,name=lastIncludedIndex,proto3" json:"lastIncludedIndex,omitempty"`
	// and including this index
	LastIncludedTerm uint64 `protobuf:"varint,4,opt,name=lastIncludedTerm,proto3" json:"lastIncludedTerm,omitempty"`
	Offset           uint64 `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	// where chunk is positioned in the snapshot file
	Data                 []byte   `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	Done                 bool     `protobuf:"varint,7,opt,name=done,proto3" json:"done,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestInstallSnapshot) Reset()         { *m = RequestInstallSnapshot{} }
func (m *RequestInstallSnapshot) String() string { return proto.CompactTextString(m) }
func (*RequestInstallSnapshot) ProtoMessage()    {}
func (*RequestInstallSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{7}
}

func (m *RequestInstallSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RequestInstallSnapshot.Unmarshal(m, b)
}
func (m *RequestInstallSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RequestInstallSnapshot.Marshal(b, m, deterministic)
}
func (m *RequestInstallSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestInstallSnapshot.Merge(m, src)
}
func (m *RequestInstallSnapshot) XXX_Size() int {
	return xxx_messageInfo_RequestInstallSnapshot.Size(m)
}
func (m *RequestInstallSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestInstallSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_RequestInstallSnapshot proto.InternalMessageInfo

func (m *RequestInstallSnapshot) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RequestInstallSnapshot) GetLeaderId() string {
	if m != nil {
		return m.LeaderId
	}
	return ""
}

func (m *RequestInstallSnapshot) GetLastIncludedIndex() uint64 {
	if m != nil {
		return m.LastIncludedIndex
	}
	return 0
}

func (m *RequestInstallSnapshot) GetLastIncludedTerm() uint64 {
	if m != nil {
		return m.LastIncludedTerm
	}
	return 0
}

func (m *RequestInstallSnapshot) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RequestInstallSnapshot) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RequestInstallSnapshot) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

type ResponseInstallSnapshot struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseInstallSnapshot) Reset()         { *m = ResponseInstallSnapshot{} }
func (m *ResponseInstallSnapshot) String() string { return proto.CompactTextString(m) }
func (*ResponseInstallSnapshot) ProtoMessage()    {}
func (*ResponseInstallSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{8}
}

func (m *ResponseInstallSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResponseInstallSnapshot.Unmarshal(m, b)
}
func (m *ResponseInstallSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResponseInstallSnapshot.Marshal(b, m, deterministic)
}
func (m *ResponseInstallSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseInstallSnapshot.Merge(m, src)
}
func (m *ResponseInstallSnapshot) XXX_Size() int {
	return xxx_messageInfo_ResponseInstallSnapshot.Size(m)
}
func (m *ResponseInstallSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseInstallSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseInstallSnapshot proto.InternalMessageInfo

type CommandRequest struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandRequest) Reset()         { *m = CommandRequest{} }
func (m *CommandRequest) String() string { return proto.CompactTextString(m) }
func (*CommandRequest) ProtoMessage()    {}
func (*CommandRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{9}
}

func (m *CommandRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandRequest.Unmarshal(m, b)
}
func (m *CommandRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandRequest.Marshal(b, m, deterministic)
}
func (m *CommandRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRequest.Merge(m, src)
}
func (m *CommandRequest) XXX_Size() int {
	return xxx_messageInfo_CommandRequest.Size(m)
}
func (m *CommandRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRequest proto.InternalMessageInfo

func (m *CommandRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CommandResponse struct {
	Leader               string   `protobuf:"bytes,1,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandResponse) Reset()         { *m = CommandResponse{} }
func (m *CommandResponse) String() string { return proto.CompactTextString(m) }
func (*CommandResponse) ProtoMessage()    {}
func (*CommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{10}
}

func (m *CommandResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandResponse.Unmarshal(m, b)
}
func (m *CommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandResponse.Marshal(b, m, deterministic)
}
func (m *CommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandResponse.Merge(m, src)
}
func (m *CommandResponse) XXX_Size() int {
	return xxx_messageInfo_CommandResponse.Size(m)
}
func (m *CommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandResponse proto.InternalMessageInfo

func (m *CommandResponse) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

type ChangeClusterResponse struct {
	Leader               string   `protobuf:"bytes,1,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeClusterResponse) Reset()         { *m = ChangeClusterResponse{} }
func (m *ChangeClusterResponse) String() string { return proto.CompactTextString(m) }
func (*ChangeClusterResponse) ProtoMessage()    {}
func (*ChangeClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{11}
}

func (m *ChangeClusterResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChangeClusterResponse.Unmarshal(m, b)
}
func (m *ChangeClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChangeClusterResponse.Marshal(b, m, deterministic)
}
func (m *ChangeClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeClusterResponse.Merge(m, src)
}
func (m *ChangeClusterResponse) XXX_Size() int {
	return xxx_messageInfo_ChangeClusterResponse.Size(m)
}
func (m *ChangeClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeClusterResponse proto.InternalMessageInfo

func (m *ChangeClusterResponse) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func init() {
	proto.RegisterEnum("raft.Status", Status_name, Status_value)
	proto.RegisterEnum("raft.Entry_Type", Entry_Type_name, Entry_Type_value)
	proto.RegisterType((*Peer)(nil), "raft.Peer")
	proto.RegisterType((*Cluster)(nil), "raft.Cluster")
	proto.RegisterType((*RequestVote)(nil), "raft.RequestVote")
	proto.RegisterType((*ResponseVote)(nil), "raft.ResponseVote")
	proto.RegisterType((*RequestAppendEntries)(nil), "raft.RequestAppendEntries")
	proto.RegisterType((*Entry)(nil), "raft.Entry")
	proto.RegisterType((*ResponseAppendEntries)(nil), "raft.ResponseAppendEntries")
	proto.RegisterType((*RequestInstallSnapshot)(nil), "raft.RequestInstallSnapshot")
	proto.RegisterType((*ResponseInstallSnapshot)(nil), "raft.ResponseInstallSnapshot")
	proto.RegisterType((*CommandRequest)(nil), "raft.CommandRequest")
	proto.RegisterType((*CommandResponse)(nil), "raft.CommandResponse")
	proto.RegisterType((*ChangeClusterResponse)(nil), "raft.ChangeClusterResponse")
}

func init() { proto.RegisterFile("raft.proto", fileDescriptor_b042552c306ae59b) }

var fileDescriptor_b042552c306ae59b = []byte{
	// 700 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x4f, 0x6f, 0xd3, 0x30,
	0x14, 0x5f, 0xda, 0xb4, 0x5d, 0xdf, 0xda, 0xad, 0xb3, 0xb6, 0x11, 0xca, 0x90, 0xaa, 0x68, 0x48,
	0x65, 0x82, 0x21, 0x0a, 0xe2, 0xc2, 0x09, 0x95, 0x09, 0x2a, 0x01, 0x42, 0xd9, 0xc4, 0xdd, 0xab,
	0x5f, 0xd7, 0x48, 0xa9, 0x1d, 0x62, 0x77, 0xb0, 0x1b, 0x1c, 0xb9, 0xf2, 0xb1, 0xf8, 0x0a, 0xdc,
	0xf8, 0x24, 0xc8, 0x8e, 0x9b, 0x39, 0xd9, 0xc4, 0xc4, 0xcd, 0xef, 0xf7, 0xfe, 0xf8, 0xfd, 0xde,
	0xef, 0x39, 0x01, 0xc8, 0xe8, 0x4c, 0x1d, 0xa5, 0x99, 0x50, 0x82, 0xf8, 0xfa, 0x1c, 0x3e, 0x07,
	0xff, 0x23, 0x62, 0x46, 0x36, 0xa1, 0x16, 0xb3, 0xc0, 0x1b, 0x78, 0xc3, 0x76, 0x54, 0x8b, 0x19,
	0xd9, 0x87, 0x36, 0x65, 0x2c, 0x43, 0x29, 0x51, 0x06, 0xb5, 0x41, 0x7d, 0xd8, 0x8e, 0xae, 0x80,
	0xf0, 0xbb, 0x07, 0xad, 0x71, 0xb2, 0x94, 0x0a, 0x33, 0x32, 0x80, 0x46, 0x8a, 0x98, 0xc9, 0xc0,
	0x1b, 0xd4, 0x87, 0x1b, 0x23, 0x38, 0x32, 0x77, 0xe8, 0xa2, 0x51, 0xee, 0x20, 0x87, 0xd0, 0x9b,
	0x23, 0xcd, 0xd4, 0x19, 0x52, 0x75, 0x1a, 0x2f, 0x50, 0x2c, 0x55, 0x50, 0x1b, 0x78, 0x43, 0x3f,
	0xba, 0x86, 0x93, 0x21, 0x6c, 0x61, 0x82, 0x53, 0x15, 0x0b, 0xbe, 0x0a, 0xad, 0x9b, 0xd0, 0x2a,
	0x1c, 0xfe, 0xf0, 0x60, 0x23, 0xc2, 0xcf, 0x4b, 0x94, 0xea, 0x93, 0x50, 0x48, 0x08, 0xf8, 0x0a,
	0xb3, 0x85, 0xe1, 0xe0, 0x47, 0xe6, 0x4c, 0x06, 0xb0, 0x31, 0xa5, 0x9c, 0xc5, 0x8c, 0x2a, 0x9c,
	0x30, 0x73, 0x69, 0x3b, 0x72, 0x21, 0x12, 0x42, 0x27, 0xa1, 0x52, 0xbd, 0x13, 0xe7, 0x13, 0xce,
	0xf0, 0xab, 0xbd, 0xac, 0x84, 0xe9, 0x2a, 0xd6, 0x3e, 0xd5, 0x17, 0xf8, 0x26, 0xc4, 0x85, 0xc2,
	0xd7, 0xd0, 0x89, 0x50, 0xa6, 0x82, 0x4b, 0xfc, 0x57, 0x2f, 0x17, 0x42, 0xe1, 0x9b, 0x8c, 0x72,
	0x85, 0x79, 0x2f, 0xeb, 0x91, 0x0b, 0x85, 0xbf, 0x3c, 0xd8, 0xb1, 0x8c, 0x5e, 0xa5, 0x29, 0x72,
	0x76, 0xcc, 0x55, 0x16, 0xa3, 0xbc, 0xb1, 0x5c, 0x1f, 0xd6, 0x13, 0xa4, 0x0c, 0xb3, 0x82, 0x57,
	0x61, 0x6b, 0x52, 0x69, 0x86, 0x17, 0x55, 0x52, 0x2e, 0xa6, 0xdb, 0xb1, 0xb6, 0x4b, 0xca, 0x81,
	0x48, 0x00, 0x2d, 0xcc, 0x1b, 0x08, 0x1a, 0x83, 0xfa, 0xb0, 0x13, 0xad, 0x4c, 0x33, 0x34, 0x73,
	0xd7, 0x58, 0x2c, 0x16, 0xb1, 0x0a, 0x9a, 0x76, 0x68, 0x0e, 0x16, 0xfe, 0xf4, 0xa0, 0xa1, 0xfb,
	0xbf, 0x24, 0x3b, 0xd0, 0x88, 0x4d, 0x1b, 0x79, 0xfb, 0xb9, 0x51, 0x70, 0xaa, 0x39, 0x9c, 0x0e,
	0xc0, 0x57, 0x97, 0x29, 0x9a, 0x7e, 0x37, 0x47, 0xbd, 0x7c, 0x93, 0x4c, 0x91, 0xa3, 0xd3, 0xcb,
	0x14, 0x23, 0xe3, 0xd5, 0x99, 0x8c, 0x2a, 0x6a, 0x5a, 0xee, 0x44, 0xe6, 0x1c, 0x3e, 0x00, 0x5f,
	0x47, 0x10, 0x80, 0x26, 0x17, 0xd9, 0x82, 0x26, 0xbd, 0x35, 0xb2, 0x0d, 0xdd, 0xe9, 0x9c, 0xf2,
	0x73, 0xb4, 0x9b, 0xda, 0xf3, 0xc2, 0x63, 0xd8, 0x5d, 0xe9, 0x74, 0xfb, 0x84, 0x03, 0x68, 0xc9,
	0xe5, 0x74, 0x8a, 0x52, 0x5a, 0xb1, 0x56, 0x66, 0xf8, 0xc7, 0x83, 0x3d, 0x2b, 0xd4, 0x84, 0x4b,
	0x45, 0x93, 0xe4, 0x84, 0xd3, 0x54, 0xce, 0x85, 0xfa, 0x6f, 0xa9, 0x1e, 0xc1, 0xb6, 0x5e, 0xa4,
	0x09, 0x9f, 0x26, 0x4b, 0x86, 0xcc, 0xd5, 0xeb, 0xba, 0x43, 0xbf, 0x24, 0x17, 0x74, 0x94, 0xbb,
	0x86, 0x93, 0x3d, 0x68, 0x8a, 0xd9, 0x4c, 0xa2, 0x0a, 0x1a, 0x26, 0xc2, 0x5a, 0xc5, 0xf8, 0x9a,
	0x57, 0xe3, 0x33, 0x98, 0xe0, 0x18, 0xb4, 0x0c, 0x4f, 0x73, 0x0e, 0xef, 0xc2, 0x9d, 0xd5, 0xac,
	0x2a, 0x24, 0xc3, 0x03, 0xd8, 0xd4, 0x2a, 0x53, 0xce, 0xec, 0x14, 0x8a, 0xa2, 0x9e, 0xa3, 0xc9,
	0x43, 0xd8, 0x2a, 0xa2, 0xf2, 0x3a, 0xba, 0xa7, 0x9c, 0xb9, 0xfd, 0xd2, 0x58, 0x2b, 0x7c, 0x02,
	0xbb, 0x63, 0x57, 0xaa, 0xdb, 0x12, 0x0e, 0x9f, 0x42, 0xf3, 0x44, 0x51, 0xb5, 0x94, 0x5a, 0xf1,
	0x1c, 0xeb, 0xad, 0x91, 0x0e, 0xac, 0xcf, 0x44, 0x92, 0x88, 0x2f, 0x5a, 0x6c, 0xd2, 0x85, 0x76,
	0xf1, 0xd2, 0x7b, 0xb5, 0xd1, 0x6f, 0x0f, 0x7a, 0x11, 0x9d, 0x29, 0x9d, 0x87, 0xef, 0xe9, 0x74,
	0x1e, 0x73, 0x24, 0x8f, 0xc1, 0x37, 0x0f, 0x76, 0x3b, 0xdf, 0x35, 0xe7, 0x7b, 0xd2, 0x27, 0x2b,
	0xc8, 0x79, 0xd7, 0x6f, 0xa1, 0x5b, 0xde, 0x9b, 0x7e, 0x29, 0xaf, 0xe4, 0xeb, 0xdf, 0x2b, 0x17,
	0x28, 0x27, 0x7e, 0x80, 0xad, 0xea, 0xea, 0xec, 0x97, 0x6a, 0x55, 0xbc, 0xfd, 0xfb, 0xe5, 0x6a,
	0x15, 0xf7, 0xe8, 0x9b, 0x07, 0xed, 0xb1, 0x76, 0x70, 0xb9, 0x94, 0xe4, 0x05, 0xb4, 0xec, 0xe8,
	0xc9, 0x4e, 0x9e, 0x57, 0xd6, 0xab, 0xbf, 0x5b, 0x41, 0xed, 0xb8, 0x5f, 0x42, 0xb7, 0xa4, 0x03,
	0xe9, 0xda, 0xb8, 0xdc, 0x5c, 0x51, 0xba, 0x51, 0xab, 0xb3, 0xa6, 0xf9, 0xaf, 0x3c, 0xfb, 0x1b,
	0x00, 0x00, 0xff, 0xff, 0x41, 0x25, 0x08, 0x42, 0x65, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftStateMachineClient is the client API for RaftStateMachine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftStateMachineClient interface {
	Vote(ctx context.Context, in *RequestVote, opts ...grpc.CallOption) (*ResponseVote, error)
	AppendEntries(ctx context.Context, in *RequestAppendEntries, opts ...grpc.CallOption) (*ResponseAppendEntries, error)
	InstallSnapshot(ctx context.Context, in *RequestInstallSnapshot, opts ...grpc.CallOption) (*ResponseInstallSnapshot, error)
}

type raftStateMachineClient struct {
	cc *grpc.ClientConn
}

func NewRaftStateMachineClient(cc *grpc.ClientConn) RaftStateMachineClient {
	return &raftStateMachineClient{cc}
}

func (c *raftStateMachineClient) Vote(ctx context.Context, in *RequestVote, opts ...grpc.CallOption) (*ResponseVote, error) {
	out := new(ResponseVote)
	err := c.cc.Invoke(ctx, "/raft.RaftStateMachine/Vote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftStateMachineClient) AppendEntries(ctx context.Context, in *RequestAppendEntries, opts ...grpc.CallOption) (*ResponseAppendEntries, error) {
	out := new(ResponseAppendEntries)
	err := c.cc.Invoke(ctx, "/raft.RaftStateMachine/AppendEntries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftStateMachineClient) InstallSnapshot(ctx context.Context, in *RequestInstallSnapshot, opts ...grpc.CallOption) (*ResponseInstallSnapshot, error) {
	out := new(ResponseInstallSnapshot)
	err := c.cc.Invoke(ctx, "/raft.RaftStateMachine/InstallSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftStateMachineServer is the server API for RaftStateMachine service.
type RaftStateMachineServer interface {
	Vote(context.Context, *RequestVote) (*ResponseVote, error)
	AppendEntries(context.Context, *RequestAppendEntries) (*ResponseAppendEntries, error)
	InstallSnapshot(context.Context, *RequestInstallSnapshot) (*ResponseInstallSnapshot, error)
}

func RegisterRaftStateMachineServer(s *grpc.Server, srv RaftStateMachineServer) {
	s.RegisterService(&_RaftStateMachine_serviceDesc, srv)
}

func _RaftStateMachine_Vote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftStateMachineServer).Vote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raft.RaftStateMachine/Vote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftStateMachineServer).Vote(ctx, req.(*RequestVote))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftStateMachine_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAppendEntries)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftStateMachineServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raft.RaftStateMachine/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftStateMachineServer).AppendEntries(ctx, req.(*RequestAppendEntries))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftStateMachine_InstallSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestInstallSnapshot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftStateMachineServer).InstallSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raft.RaftStateMachine/InstallSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftStateMachineServer).InstallSnapshot(ctx, req.(*RequestInstallSnapshot))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftStateMachine_serviceDesc = grpc.ServiceDesc{
	ServiceName: "raft.RaftStateMachine",
	HandlerType: (*RaftStateMachineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Vote",
			Handler:    _RaftStateMachine_Vote_Handler,
		},
		{
			MethodName: "AppendEntries",
			Handler:    _RaftStateMachine_AppendEntries_Handler,
		},
		{
			MethodName: "InstallSnapshot",
			Handler:    _RaftStateMachine_InstallSnapshot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "raft.proto",
}

// ConsensusClient is the client API for Consensus service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConsensusClient interface {
	Command(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
	ChangeCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*ChangeClusterResponse, error)
}

type consensusClient struct {
	cc *grpc.ClientConn
}

func NewConsensusClient(cc *grpc.ClientConn) ConsensusClient {
	return &consensusClient{cc}
}

func (c *consensusClient) Command(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/raft.Consensus/Command", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusClient) ChangeCluster(ctx context.Context, in *Cluster, opts ...grpc.CallOption) (*ChangeClusterResponse, error) {
	out := new(ChangeClusterResponse)
	err := c.cc.Invoke(ctx, "/raft.Consensus/ChangeCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsensusServer is the server API for Consensus service.
type ConsensusServer interface {
	Command(context.Context, *CommandRequest) (*CommandResponse, error)
	ChangeCluster(context.Context, *Cluster) (*ChangeClusterResponse, error)
}

func RegisterConsensusServer(s *grpc.Server, srv ConsensusServer) {
	s.RegisterService(&_Consensus_serviceDesc, srv)
}

func _Consensus_Command_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServer).Command(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raft.Consensus/Command",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServer).Command(ctx, req.(*CommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Consensus_ChangeCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Cluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServer).ChangeCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/raft.Consensus/ChangeCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServer).ChangeCluster(ctx, req.(*Cluster))
	}
	return interceptor(ctx, in, info, handler)
}

var _Consensus_serviceDesc = grpc.ServiceDesc{
	ServiceName: "raft.Consensus",
	HandlerType: (*ConsensusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Command",
			Handler:    _Consensus_Command_Handler,
		},
		{
			MethodName: "ChangeCluster",
			Handler:    _Consensus_ChangeCluster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "raft.proto",
}
