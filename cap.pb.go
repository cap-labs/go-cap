// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.23.0
// 	protoc        v3.15.5
// source: cap.proto

package cap

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

/// Transport packet object
type Packet struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"` // Packet from peer id
	To   string `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`     // Packet to peer id
	Data []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"` // Packet data field
}

func (x *Packet) Reset() {
	*x = Packet{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Packet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Packet) ProtoMessage() {}

func (x *Packet) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Packet.ProtoReflect.Descriptor instead.
func (*Packet) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{0}
}

func (x *Packet) GetFrom() string {
	if x != nil {
		return x.From
	}
	return ""
}

func (x *Packet) GetTo() string {
	if x != nil {
		return x.To
	}
	return ""
}

func (x *Packet) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type PutPeerRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Addrs []string `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"` // peers addr
}

func (x *PutPeerRequest) Reset() {
	*x = PutPeerRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PutPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutPeerRequest) ProtoMessage() {}

func (x *PutPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutPeerRequest.ProtoReflect.Descriptor instead.
func (*PutPeerRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{1}
}

func (x *PutPeerRequest) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

type PutPeerResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *PutPeerResponse) Reset() {
	*x = PutPeerResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PutPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutPeerResponse) ProtoMessage() {}

func (x *PutPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutPeerResponse.ProtoReflect.Descriptor instead.
func (*PutPeerResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{2}
}

type GetPeerRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Peers string `protobuf:"bytes,1,opt,name=peers,proto3" json:"peers,omitempty"` // peer id array
}

func (x *GetPeerRequest) Reset() {
	*x = GetPeerRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPeerRequest) ProtoMessage() {}

func (x *GetPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPeerRequest.ProtoReflect.Descriptor instead.
func (*GetPeerRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{3}
}

func (x *GetPeerRequest) GetPeers() string {
	if x != nil {
		return x.Peers
	}
	return ""
}

type GetPeerResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"` // peer addr
}

func (x *GetPeerResponse) Reset() {
	*x = GetPeerResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPeerResponse) ProtoMessage() {}

func (x *GetPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPeerResponse.ProtoReflect.Descriptor instead.
func (*GetPeerResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{4}
}

func (x *GetPeerResponse) GetAddr() string {
	if x != nil {
		return x.Addr
	}
	return ""
}

type ExecRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"` //
}

func (x *ExecRequest) Reset() {
	*x = ExecRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecRequest) ProtoMessage() {}

func (x *ExecRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecRequest.ProtoReflect.Descriptor instead.
func (*ExecRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{5}
}

func (x *ExecRequest) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type ExecResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *ExecResponse) Reset() {
	*x = ExecResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ExecResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecResponse) ProtoMessage() {}

func (x *ExecResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecResponse.ProtoReflect.Descriptor instead.
func (*ExecResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{6}
}

/// RPC data packet
type RPCPacket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (x *RPCPacket) Reset() {
	*x = RPCPacket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RPCPacket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCPacket) ProtoMessage() {}

func (x *RPCPacket) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCPacket.ProtoReflect.Descriptor instead.
func (*RPCPacket) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{7}
}

func (x *RPCPacket) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

/// Put state request message
type PutStateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	State    []byte   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`        /// state name
	Capacity uint64   `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"` /// advise state maximum storage capacity in bytes
	Keys     [][]byte `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys,omitempty"`          /// Put value associate key
	Values   [][]byte `protobuf:"bytes,4,rep,name=values,proto3" json:"values,omitempty"`      /// Put value data
}

func (x *PutStateRequest) Reset() {
	*x = PutStateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PutStateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutStateRequest) ProtoMessage() {}

func (x *PutStateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutStateRequest.ProtoReflect.Descriptor instead.
func (*PutStateRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{8}
}

func (x *PutStateRequest) GetState() []byte {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *PutStateRequest) GetCapacity() uint64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

func (x *PutStateRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *PutStateRequest) GetValues() [][]byte {
	if x != nil {
		return x.Values
	}
	return nil
}

/// Put state response message
type PutStateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	State   []byte `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`      /// state name
	Size    uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`       /// state current storage size in bytes
	Written uint64 `protobuf:"varint,3,opt,name=written,proto3" json:"written,omitempty"` /// written data in bytes, zero if out of capacity
}

func (x *PutStateResponse) Reset() {
	*x = PutStateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PutStateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutStateResponse) ProtoMessage() {}

func (x *PutStateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutStateResponse.ProtoReflect.Descriptor instead.
func (*PutStateResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{9}
}

func (x *PutStateResponse) GetState() []byte {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *PutStateResponse) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *PutStateResponse) GetWritten() uint64 {
	if x != nil {
		return x.Written
	}
	return 0
}

/// batch put state request
type BatchPutStateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Batch []*PutStateRequest `protobuf:"bytes,1,rep,name=batch,proto3" json:"batch,omitempty"` /// request array
}

func (x *BatchPutStateRequest) Reset() {
	*x = BatchPutStateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchPutStateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchPutStateRequest) ProtoMessage() {}

func (x *BatchPutStateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchPutStateRequest.ProtoReflect.Descriptor instead.
func (*BatchPutStateRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{10}
}

func (x *BatchPutStateRequest) GetBatch() []*PutStateRequest {
	if x != nil {
		return x.Batch
	}
	return nil
}

/// batch put state response
type BatchPutStateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Batch []*PutStateResponse `protobuf:"bytes,1,rep,name=batch,proto3" json:"batch,omitempty"` ///  response array
}

func (x *BatchPutStateResponse) Reset() {
	*x = BatchPutStateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchPutStateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchPutStateResponse) ProtoMessage() {}

func (x *BatchPutStateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchPutStateResponse.ProtoReflect.Descriptor instead.
func (*BatchPutStateResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{11}
}

func (x *BatchPutStateResponse) GetBatch() []*PutStateResponse {
	if x != nil {
		return x.Batch
	}
	return nil
}

type GetStateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	State []byte   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"` /// state name
	Keys  [][]byte `protobuf:"bytes,3,rep,name=keys,proto3" json:"keys,omitempty"`   /// get value associate keys
}

func (x *GetStateRequest) Reset() {
	*x = GetStateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStateRequest) ProtoMessage() {}

func (x *GetStateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStateRequest.ProtoReflect.Descriptor instead.
func (*GetStateRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{12}
}

func (x *GetStateRequest) GetState() []byte {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *GetStateRequest) GetKeys() [][]byte {
	if x != nil {
		return x.Keys
	}
	return nil
}

type GetStateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	State  []byte   `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`   /// state name
	Size   uint64   `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`    /// state current storage size in bytes
	Values [][]byte `protobuf:"bytes,4,rep,name=values,proto3" json:"values,omitempty"` /// get values data
}

func (x *GetStateResponse) Reset() {
	*x = GetStateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GetStateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStateResponse) ProtoMessage() {}

func (x *GetStateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStateResponse.ProtoReflect.Descriptor instead.
func (*GetStateResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{13}
}

func (x *GetStateResponse) GetState() []byte {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *GetStateResponse) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *GetStateResponse) GetValues() [][]byte {
	if x != nil {
		return x.Values
	}
	return nil
}

/// batch put state request
type BatchGetStateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Batch []*GetStateRequest `protobuf:"bytes,1,rep,name=batch,proto3" json:"batch,omitempty"` /// request array
}

func (x *BatchGetStateRequest) Reset() {
	*x = BatchGetStateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchGetStateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetStateRequest) ProtoMessage() {}

func (x *BatchGetStateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetStateRequest.ProtoReflect.Descriptor instead.
func (*BatchGetStateRequest) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{14}
}

func (x *BatchGetStateRequest) GetBatch() []*GetStateRequest {
	if x != nil {
		return x.Batch
	}
	return nil
}

/// batch put state response
type BatchGetStateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Batch []*GetStateResponse `protobuf:"bytes,1,rep,name=batch,proto3" json:"batch,omitempty"` ///  response array
}

func (x *BatchGetStateResponse) Reset() {
	*x = BatchGetStateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cap_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchGetStateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchGetStateResponse) ProtoMessage() {}

func (x *BatchGetStateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cap_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchGetStateResponse.ProtoReflect.Descriptor instead.
func (*BatchGetStateResponse) Descriptor() ([]byte, []int) {
	return file_cap_proto_rawDescGZIP(), []int{15}
}

func (x *BatchGetStateResponse) GetBatch() []*GetStateResponse {
	if x != nil {
		return x.Batch
	}
	return nil
}

var File_cap_proto protoreflect.FileDescriptor

var file_cap_proto_rawDesc = []byte{
	0x0a, 0x09, 0x63, 0x61, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x03, 0x63, 0x61, 0x70,
	0x22, 0x40, 0x0a, 0x06, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x66, 0x72,
	0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x66, 0x72, 0x6f, 0x6d, 0x12, 0x0e,
	0x0a, 0x02, 0x74, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x6f, 0x12, 0x12,
	0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61,
	0x74, 0x61, 0x22, 0x26, 0x0a, 0x0e, 0x50, 0x75, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x61, 0x64, 0x64, 0x72, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x05, 0x61, 0x64, 0x64, 0x72, 0x73, 0x22, 0x11, 0x0a, 0x0f, 0x50, 0x75,
	0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x26, 0x0a,
	0x0e, 0x47, 0x65, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x14, 0x0a, 0x05, 0x70, 0x65, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x70, 0x65, 0x65, 0x72, 0x73, 0x22, 0x25, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x50, 0x65, 0x65, 0x72,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x64, 0x64, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x61, 0x64, 0x64, 0x72, 0x22, 0x21, 0x0a, 0x0b,
	0x45, 0x78, 0x65, 0x63, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x64,
	0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61, 0x22,
	0x0e, 0x0a, 0x0c, 0x45, 0x78, 0x65, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x1f, 0x0a, 0x09, 0x52, 0x50, 0x43, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04,
	0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61,
	0x22, 0x6f, 0x0a, 0x0f, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x61, 0x70,
	0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x63, 0x61, 0x70,
	0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x0c, 0x52, 0x04, 0x6b, 0x65, 0x79, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x73, 0x22, 0x56, 0x0a, 0x10, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73,
	0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12,
	0x18, 0x0a, 0x07, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04,
	0x52, 0x07, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x22, 0x42, 0x0a, 0x14, 0x42, 0x61, 0x74,
	0x63, 0x68, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x2a, 0x0a, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x14, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x22, 0x44, 0x0a,
	0x15, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x75, 0x74, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x05, 0x62, 0x61,
	0x74, 0x63, 0x68, 0x22, 0x3b, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x04,
	0x6b, 0x65, 0x79, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x6b, 0x65, 0x79, 0x73,
	0x22, 0x54, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69,
	0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x12, 0x16,
	0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x06,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0x42, 0x0a, 0x14, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47,
	0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2a,
	0x0a, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e,
	0x63, 0x61, 0x70, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x52, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x22, 0x44, 0x0a, 0x15, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x15, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x05, 0x62, 0x61, 0x74, 0x63, 0x68,
	0x32, 0x33, 0x0a, 0x09, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x26, 0x0a,
	0x06, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x12, 0x0b, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x61,
	0x63, 0x6b, 0x65, 0x74, 0x1a, 0x0b, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x65,
	0x74, 0x28, 0x01, 0x30, 0x01, 0x32, 0x6f, 0x0a, 0x09, 0x50, 0x65, 0x65, 0x72, 0x53, 0x74, 0x6f,
	0x72, 0x65, 0x12, 0x30, 0x0a, 0x03, 0x70, 0x75, 0x74, 0x12, 0x13, 0x2e, 0x63, 0x61, 0x70, 0x2e,
	0x50, 0x75, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14,
	0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x75, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x30, 0x0a, 0x03, 0x67, 0x65, 0x74, 0x12, 0x13, 0x2e, 0x63, 0x61,
	0x70, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x1a, 0x14, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x47, 0x65, 0x74, 0x50, 0x65, 0x65, 0x72, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0x32, 0x0a, 0x03, 0x41, 0x70, 0x70, 0x12, 0x2b, 0x0a,
	0x04, 0x65, 0x78, 0x65, 0x63, 0x12, 0x10, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x45, 0x78, 0x65, 0x63,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x45, 0x78,
	0x65, 0x63, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x32, 0x31, 0x0a, 0x03, 0x52, 0x50,
	0x43, 0x12, 0x2a, 0x0a, 0x08, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x12, 0x0e, 0x2e,
	0x63, 0x61, 0x70, 0x2e, 0x52, 0x50, 0x43, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x1a, 0x0e, 0x2e,
	0x63, 0x61, 0x70, 0x2e, 0x52, 0x50, 0x43, 0x50, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x32, 0xf5, 0x01,
	0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x32, 0x0a, 0x03, 0x70, 0x75, 0x74, 0x12, 0x14,
	0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x50, 0x75, 0x74, 0x53, 0x74,
	0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x08, 0x62,
	0x61, 0x74, 0x63, 0x68, 0x50, 0x75, 0x74, 0x12, 0x19, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x50, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x75,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x32,
	0x0a, 0x03, 0x67, 0x65, 0x74, 0x12, 0x14, 0x2e, 0x63, 0x61, 0x70, 0x2e, 0x47, 0x65, 0x74, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x15, 0x2e, 0x63, 0x61,
	0x70, 0x2e, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x41, 0x0a, 0x08, 0x62, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x12, 0x19,
	0x2e, 0x63, 0x61, 0x70, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61,
	0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x63, 0x61, 0x70, 0x2e,
	0x42, 0x61, 0x74, 0x63, 0x68, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x20, 0x5a, 0x1e, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
	0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x61, 0x70, 0x2d, 0x6c, 0x61, 0x62, 0x73, 0x2f, 0x67, 0x6f, 0x2d,
	0x63, 0x61, 0x70, 0x3b, 0x63, 0x61, 0x70, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_cap_proto_rawDescOnce sync.Once
	file_cap_proto_rawDescData = file_cap_proto_rawDesc
)

func file_cap_proto_rawDescGZIP() []byte {
	file_cap_proto_rawDescOnce.Do(func() {
		file_cap_proto_rawDescData = protoimpl.X.CompressGZIP(file_cap_proto_rawDescData)
	})
	return file_cap_proto_rawDescData
}

var file_cap_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_cap_proto_goTypes = []interface{}{
	(*Packet)(nil),                // 0: cap.Packet
	(*PutPeerRequest)(nil),        // 1: cap.PutPeerRequest
	(*PutPeerResponse)(nil),       // 2: cap.PutPeerResponse
	(*GetPeerRequest)(nil),        // 3: cap.GetPeerRequest
	(*GetPeerResponse)(nil),       // 4: cap.GetPeerResponse
	(*ExecRequest)(nil),           // 5: cap.ExecRequest
	(*ExecResponse)(nil),          // 6: cap.ExecResponse
	(*RPCPacket)(nil),             // 7: cap.RPCPacket
	(*PutStateRequest)(nil),       // 8: cap.PutStateRequest
	(*PutStateResponse)(nil),      // 9: cap.PutStateResponse
	(*BatchPutStateRequest)(nil),  // 10: cap.BatchPutStateRequest
	(*BatchPutStateResponse)(nil), // 11: cap.BatchPutStateResponse
	(*GetStateRequest)(nil),       // 12: cap.GetStateRequest
	(*GetStateResponse)(nil),      // 13: cap.GetStateResponse
	(*BatchGetStateRequest)(nil),  // 14: cap.BatchGetStateRequest
	(*BatchGetStateResponse)(nil), // 15: cap.BatchGetStateResponse
}
var file_cap_proto_depIdxs = []int32{
	8,  // 0: cap.BatchPutStateRequest.batch:type_name -> cap.PutStateRequest
	9,  // 1: cap.BatchPutStateResponse.batch:type_name -> cap.PutStateResponse
	12, // 2: cap.BatchGetStateRequest.batch:type_name -> cap.GetStateRequest
	13, // 3: cap.BatchGetStateResponse.batch:type_name -> cap.GetStateResponse
	0,  // 4: cap.Transport.handle:input_type -> cap.Packet
	1,  // 5: cap.PeerStore.put:input_type -> cap.PutPeerRequest
	3,  // 6: cap.PeerStore.get:input_type -> cap.GetPeerRequest
	5,  // 7: cap.App.exec:input_type -> cap.ExecRequest
	7,  // 8: cap.RPC.dispatch:input_type -> cap.RPCPacket
	8,  // 9: cap.State.put:input_type -> cap.PutStateRequest
	10, // 10: cap.State.batchPut:input_type -> cap.BatchPutStateRequest
	12, // 11: cap.State.get:input_type -> cap.GetStateRequest
	14, // 12: cap.State.batchGet:input_type -> cap.BatchGetStateRequest
	0,  // 13: cap.Transport.handle:output_type -> cap.Packet
	2,  // 14: cap.PeerStore.put:output_type -> cap.PutPeerResponse
	4,  // 15: cap.PeerStore.get:output_type -> cap.GetPeerResponse
	6,  // 16: cap.App.exec:output_type -> cap.ExecResponse
	7,  // 17: cap.RPC.dispatch:output_type -> cap.RPCPacket
	9,  // 18: cap.State.put:output_type -> cap.PutStateResponse
	11, // 19: cap.State.batchPut:output_type -> cap.BatchPutStateResponse
	13, // 20: cap.State.get:output_type -> cap.GetStateResponse
	15, // 21: cap.State.batchGet:output_type -> cap.BatchGetStateResponse
	13, // [13:22] is the sub-list for method output_type
	4,  // [4:13] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_cap_proto_init() }
func file_cap_proto_init() {
	if File_cap_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cap_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Packet); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PutPeerRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PutPeerResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetPeerRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetPeerResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RPCPacket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PutStateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PutStateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchPutStateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchPutStateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GetStateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchGetStateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cap_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchGetStateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cap_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   5,
		},
		GoTypes:           file_cap_proto_goTypes,
		DependencyIndexes: file_cap_proto_depIdxs,
		MessageInfos:      file_cap_proto_msgTypes,
	}.Build()
	File_cap_proto = out.File
	file_cap_proto_rawDesc = nil
	file_cap_proto_goTypes = nil
	file_cap_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// TransportClient is the client API for Transport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TransportClient interface {
	/// handle transport send/recv packet
	Handle(ctx context.Context, opts ...grpc.CallOption) (Transport_HandleClient, error)
}

type transportClient struct {
	cc grpc.ClientConnInterface
}

func NewTransportClient(cc grpc.ClientConnInterface) TransportClient {
	return &transportClient{cc}
}

func (c *transportClient) Handle(ctx context.Context, opts ...grpc.CallOption) (Transport_HandleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Transport_serviceDesc.Streams[0], "/cap.Transport/handle", opts...)
	if err != nil {
		return nil, err
	}
	x := &transportHandleClient{stream}
	return x, nil
}

type Transport_HandleClient interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ClientStream
}

type transportHandleClient struct {
	grpc.ClientStream
}

func (x *transportHandleClient) Send(m *Packet) error {
	return x.ClientStream.SendMsg(m)
}

func (x *transportHandleClient) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TransportServer is the server API for Transport service.
type TransportServer interface {
	/// handle transport send/recv packet
	Handle(Transport_HandleServer) error
}

// UnimplementedTransportServer can be embedded to have forward compatible implementations.
type UnimplementedTransportServer struct {
}

func (*UnimplementedTransportServer) Handle(Transport_HandleServer) error {
	return status.Errorf(codes.Unimplemented, "method Handle not implemented")
}

func RegisterTransportServer(s *grpc.Server, srv TransportServer) {
	s.RegisterService(&_Transport_serviceDesc, srv)
}

func _Transport_Handle_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TransportServer).Handle(&transportHandleServer{stream})
}

type Transport_HandleServer interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ServerStream
}

type transportHandleServer struct {
	grpc.ServerStream
}

func (x *transportHandleServer) Send(m *Packet) error {
	return x.ServerStream.SendMsg(m)
}

func (x *transportHandleServer) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Transport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cap.Transport",
	HandlerType: (*TransportServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "handle",
			Handler:       _Transport_Handle_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cap.proto",
}

// PeerStoreClient is the client API for PeerStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PeerStoreClient interface {
	/// set peers
	Put(ctx context.Context, in *PutPeerRequest, opts ...grpc.CallOption) (*PutPeerResponse, error)
	/// get peers
	Get(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*GetPeerResponse, error)
}

type peerStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewPeerStoreClient(cc grpc.ClientConnInterface) PeerStoreClient {
	return &peerStoreClient{cc}
}

func (c *peerStoreClient) Put(ctx context.Context, in *PutPeerRequest, opts ...grpc.CallOption) (*PutPeerResponse, error) {
	out := new(PutPeerResponse)
	err := c.cc.Invoke(ctx, "/cap.PeerStore/put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerStoreClient) Get(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*GetPeerResponse, error) {
	out := new(GetPeerResponse)
	err := c.cc.Invoke(ctx, "/cap.PeerStore/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PeerStoreServer is the server API for PeerStore service.
type PeerStoreServer interface {
	/// set peers
	Put(context.Context, *PutPeerRequest) (*PutPeerResponse, error)
	/// get peers
	Get(context.Context, *GetPeerRequest) (*GetPeerResponse, error)
}

// UnimplementedPeerStoreServer can be embedded to have forward compatible implementations.
type UnimplementedPeerStoreServer struct {
}

func (*UnimplementedPeerStoreServer) Put(context.Context, *PutPeerRequest) (*PutPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedPeerStoreServer) Get(context.Context, *GetPeerRequest) (*GetPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterPeerStoreServer(s *grpc.Server, srv PeerStoreServer) {
	s.RegisterService(&_PeerStore_serviceDesc, srv)
}

func _PeerStore_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerStoreServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.PeerStore/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerStoreServer).Put(ctx, req.(*PutPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerStore_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerStoreServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.PeerStore/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerStoreServer).Get(ctx, req.(*GetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PeerStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cap.PeerStore",
	HandlerType: (*PeerStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "put",
			Handler:    _PeerStore_Put_Handler,
		},
		{
			MethodName: "get",
			Handler:    _PeerStore_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cap.proto",
}

// AppClient is the client API for App service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppClient interface {
	/// exec
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error)
}

type appClient struct {
	cc grpc.ClientConnInterface
}

func NewAppClient(cc grpc.ClientConnInterface) AppClient {
	return &appClient{cc}
}

func (c *appClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (*ExecResponse, error) {
	out := new(ExecResponse)
	err := c.cc.Invoke(ctx, "/cap.App/exec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppServer is the server API for App service.
type AppServer interface {
	/// exec
	Exec(context.Context, *ExecRequest) (*ExecResponse, error)
}

// UnimplementedAppServer can be embedded to have forward compatible implementations.
type UnimplementedAppServer struct {
}

func (*UnimplementedAppServer) Exec(context.Context, *ExecRequest) (*ExecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exec not implemented")
}

func RegisterAppServer(s *grpc.Server, srv AppServer) {
	s.RegisterService(&_App_serviceDesc, srv)
}

func _App_Exec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppServer).Exec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.App/Exec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppServer).Exec(ctx, req.(*ExecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _App_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cap.App",
	HandlerType: (*AppServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "exec",
			Handler:    _App_Exec_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cap.proto",
}

// RPCClient is the client API for RPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCClient interface {
	/// dispatch rpc packet
	Dispatch(ctx context.Context, in *RPCPacket, opts ...grpc.CallOption) (*RPCPacket, error)
}

type rPCClient struct {
	cc grpc.ClientConnInterface
}

func NewRPCClient(cc grpc.ClientConnInterface) RPCClient {
	return &rPCClient{cc}
}

func (c *rPCClient) Dispatch(ctx context.Context, in *RPCPacket, opts ...grpc.CallOption) (*RPCPacket, error) {
	out := new(RPCPacket)
	err := c.cc.Invoke(ctx, "/cap.RPC/dispatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCServer is the server API for RPC service.
type RPCServer interface {
	/// dispatch rpc packet
	Dispatch(context.Context, *RPCPacket) (*RPCPacket, error)
}

// UnimplementedRPCServer can be embedded to have forward compatible implementations.
type UnimplementedRPCServer struct {
}

func (*UnimplementedRPCServer) Dispatch(context.Context, *RPCPacket) (*RPCPacket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispatch not implemented")
}

func RegisterRPCServer(s *grpc.Server, srv RPCServer) {
	s.RegisterService(&_RPC_serviceDesc, srv)
}

func _RPC_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPCPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.RPC/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Dispatch(ctx, req.(*RPCPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cap.RPC",
	HandlerType: (*RPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dispatch",
			Handler:    _RPC_Dispatch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cap.proto",
}

// StateClient is the client API for State service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StateClient interface {
	Put(ctx context.Context, in *PutStateRequest, opts ...grpc.CallOption) (*PutStateResponse, error)
	BatchPut(ctx context.Context, in *BatchPutStateRequest, opts ...grpc.CallOption) (*BatchPutStateResponse, error)
	Get(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error)
	BatchGet(ctx context.Context, in *BatchGetStateRequest, opts ...grpc.CallOption) (*BatchGetStateResponse, error)
}

type stateClient struct {
	cc grpc.ClientConnInterface
}

func NewStateClient(cc grpc.ClientConnInterface) StateClient {
	return &stateClient{cc}
}

func (c *stateClient) Put(ctx context.Context, in *PutStateRequest, opts ...grpc.CallOption) (*PutStateResponse, error) {
	out := new(PutStateResponse)
	err := c.cc.Invoke(ctx, "/cap.State/put", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateClient) BatchPut(ctx context.Context, in *BatchPutStateRequest, opts ...grpc.CallOption) (*BatchPutStateResponse, error) {
	out := new(BatchPutStateResponse)
	err := c.cc.Invoke(ctx, "/cap.State/batchPut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateClient) Get(ctx context.Context, in *GetStateRequest, opts ...grpc.CallOption) (*GetStateResponse, error) {
	out := new(GetStateResponse)
	err := c.cc.Invoke(ctx, "/cap.State/get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stateClient) BatchGet(ctx context.Context, in *BatchGetStateRequest, opts ...grpc.CallOption) (*BatchGetStateResponse, error) {
	out := new(BatchGetStateResponse)
	err := c.cc.Invoke(ctx, "/cap.State/batchGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StateServer is the server API for State service.
type StateServer interface {
	Put(context.Context, *PutStateRequest) (*PutStateResponse, error)
	BatchPut(context.Context, *BatchPutStateRequest) (*BatchPutStateResponse, error)
	Get(context.Context, *GetStateRequest) (*GetStateResponse, error)
	BatchGet(context.Context, *BatchGetStateRequest) (*BatchGetStateResponse, error)
}

// UnimplementedStateServer can be embedded to have forward compatible implementations.
type UnimplementedStateServer struct {
}

func (*UnimplementedStateServer) Put(context.Context, *PutStateRequest) (*PutStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (*UnimplementedStateServer) BatchPut(context.Context, *BatchPutStateRequest) (*BatchPutStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchPut not implemented")
}
func (*UnimplementedStateServer) Get(context.Context, *GetStateRequest) (*GetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedStateServer) BatchGet(context.Context, *BatchGetStateRequest) (*BatchGetStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGet not implemented")
}

func RegisterStateServer(s *grpc.Server, srv StateServer) {
	s.RegisterService(&_State_serviceDesc, srv)
}

func _State_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.State/Put",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServer).Put(ctx, req.(*PutStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _State_BatchPut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchPutStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServer).BatchPut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.State/BatchPut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServer).BatchPut(ctx, req.(*BatchPutStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _State_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.State/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServer).Get(ctx, req.(*GetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _State_BatchGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StateServer).BatchGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cap.State/BatchGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StateServer).BatchGet(ctx, req.(*BatchGetStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _State_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cap.State",
	HandlerType: (*StateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "put",
			Handler:    _State_Put_Handler,
		},
		{
			MethodName: "batchPut",
			Handler:    _State_BatchPut_Handler,
		},
		{
			MethodName: "get",
			Handler:    _State_Get_Handler,
		},
		{
			MethodName: "batchGet",
			Handler:    _State_BatchGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cap.proto",
}
